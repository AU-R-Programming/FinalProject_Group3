library(MASS)          # For mvrnorm()
library(wv)            # For wvar() - Wavelet variance estimation
library(wavelets)      # For wt.filter() - To obtain wavelet filter
# Define the Generalized Method of Wavelet Moments (GMWM) simulation study
gmwm_simulation_study <- function(theta_true = 2, d = 128, n_simulations = 100) {
# Arguments:
# theta_true: True value of the parameter to estimate
# d: Dimension of the identity matrix (must be a power of 2)
# n_simulations: Number of simulations to perform
# Initialize storage for GMWM estimates
theta_estimates <- numeric(n_simulations)
# Define GMWM objective function
gmwm_objective <- function(theta, sample_variance, Omega) {
theoretical_variance <- numeric(J)
# Compute the theoretical wavelet variance for each level
for (j in 1:J) {
out <- wt.filter(filter = "haar", level = j)
filter <- out@h
I_j <- diag(2^j)               # Identity matrix of dimension 2^j x 2^j
Sigma_j_theta <- I_j * theta   # Compute Sigma_j(theta)
A_j <- filter %*% t(filter)    # Matrix A_j (related to Haar filter)
# Compute theoretical wavelet variance
theoretical_variance[j] <- sum(diag(A_j %*% Sigma_j_theta)) / (2^j)
}
# Compute the GMWM objective function
diff <- sample_variance - theoretical_variance
return(t(diff) %*% Omega %*% diff)
}
# Perform the simulation study
set.seed(123)
for (i in 1:n_simulations) {
# Simulate data using mvrnorm()
sample <- mvrnorm(n = 1, mu = rep(0, d), Sigma = diag(d) * theta_true)
# Estimate wavelet variance (robust or not)
J <- floor(log2(d)) - 1  # Number of levels for Haar wavelet variance
sample_variance <- suppressWarnings(wvar(sample, filter = "haar", n.levels = J)$variance)
# Weighting matrix (Identity matrix by default)
Omega <- diag(length(sample_variance))
# Optimize to get GMWM estimate for theta
result <- optim(par = 1, fn = gmwm_objective, sample_variance = sample_variance, Omega = Omega)
theta_estimates[i] <- result$par
}
# Set up plot margins to avoid figure margins error
dev.new(width = 8, height = 6)
par(mar = c(5, 4, 4, 2) + 0.1)
# Plotting the results using boxplot
boxplot(theta_estimates, main = "GMWM Estimates of Theta", ylab = "Theta Estimates")
# Calculate the Median Absolute Error (MAE)
MAE <- median(abs(theta_estimates - theta_true))
cat("Median Absolute Error (MAE):", MAE, "\n")
return(list(theta_estimates = theta_estimates, MAE = MAE))
}
# Run the simulation study
d <- 128
result <- gmwm_simulation_study(theta_true = 2, d = d, n_simulations = 100)
# Output the results
cat("Median Absolute Error (MAE):", result$MAE, "\n")
gmwm_estimate <- function(d, initial_theta = 1, max_iter = 1000, tol = 1e-5) {
# Step 1: Generate a sample from the zero-mean process with covariance matrix Σ(θ)
set.seed(123)  # For reproducibility
I_d <- diag(d)  # Identity matrix of size d x d
theta_true <- 1  # True value of theta (for simulation purposes)
sample <- mvrnorm(n = 1, mu = rep(0, d), Sigma = theta_true * I_d)
# Step 2: Estimate wavelet variance on the sample using Haar wavelet
J <- floor(log2(d)) - 1  # Number of levels for Haar wavelet variance
estimated_wavelet_variance <- wvar(sample, filter = "haar", levels = J)$variance
# Step 3: Define the theoretical wavelet variance function as a function of θ
theoretical_wavelet_variance <- function(theta) {
# Theoretical wavelet variance implied by the process of interest
rep(theta, length(estimated_wavelet_variance))  # Assumes a simple linear relationship
}
# Step 4: Define the GMWM objective function to minimize
gmwm_objective <- function(theta) {
# Weighting matrix Ω (identity matrix for simplicity)
Omega <- diag(J)
# Compute the difference between estimated and theoretical wavelet variance
nu_hat <- estimated_wavelet_variance
nu_theta <- theoretical_wavelet_variance(theta)
diff <- nu_hat - nu_theta
# GMWM loss function: (ν̂ - ν(θ))' * Ω * (ν̂ - ν(θ))
t(diff) %*% Omega %*% diff
}
# Step 5: Optimize the objective function to estimate θ
result <- optim(par = initial_theta, fn = gmwm_objective, method = "BFGS",
control = list(maxit = max_iter, reltol = tol))
# Return the estimated value of θ
return(list(estimated_theta = result$par, convergence = result$convergence))
}
#######Problem2
#############################
# Required Libraries
library(MASS)          # For mvrnorm()
library(wv)            # For wvar() - Wavelet variance estimation
library(wavelets)      # For wt.filter() - To obtain wavelet filter
# Define the Generalized Method of Wavelet Moments (GMWM) simulation study
gmwm_simulation_study <- function(theta_true = 2, d = 128, n_simulations = 100) {
# Arguments:
# theta_true: True value of the parameter to estimate
# d: Dimension of the identity matrix (must be a power of 2)
# n_simulations: Number of simulations to perform
# Initialize storage for GMWM estimates
theta_estimates <- numeric(n_simulations)
# Define GMWM objective function
gmwm_objective <- function(theta, sample_variance, Omega) {
theoretical_variance <- numeric(J)
# Compute the theoretical wavelet variance for each level
for (j in 1:J) {
out <- wt.filter(filter = "haar", level = j)
filter <- out@h
I_j <- diag(2^j)               # Identity matrix of dimension 2^j x 2^j
Sigma_j_theta <- I_j * theta   # Compute Sigma_j(theta)
A_j <- filter %*% t(filter)    # Matrix A_j (related to Haar filter)
# Compute theoretical wavelet variance
theoretical_variance[j] <- sum(diag(A_j %*% Sigma_j_theta)) / (2^j)
}
# Compute the GMWM objective function
diff <- sample_variance - theoretical_variance
return(t(diff) %*% Omega %*% diff)
}
# Perform the simulation study
set.seed(123)
for (i in 1:n_simulations) {
# Simulate data using mvrnorm()
sample <- mvrnorm(n = 1, mu = rep(0, d), Sigma = diag(d) * theta_true)
# Estimate wavelet variance (robust or not)
J <- floor(log2(d)) - 1  # Number of levels for Haar wavelet variance
sample_variance <- suppressWarnings(wvar(sample, filter = "haar", n.levels = J)$variance)
# Weighting matrix (Identity matrix by default)
Omega <- diag(length(sample_variance))
# Optimize to get GMWM estimate for theta
result <- optim(par = 1, fn = gmwm_objective, sample_variance = sample_variance, Omega = Omega)
theta_estimates[i] <- result$par
}
# Set up plot margins to avoid figure margins error
dev.new(width = 8, height = 6)
par(mar = c(5, 4, 4, 2) + 0.1)
# Plotting the results using boxplot
boxplot(theta_estimates, main = "GMWM Estimates of Theta", ylab = "Theta Estimates")
# Calculate the Median Absolute Error (MAE)
MAE <- median(abs(theta_estimates - theta_true))
cat("Median Absolute Error (MAE):", MAE, "\n")
return(list(theta_estimates = theta_estimates, MAE = MAE))
}
# Run the simulation study
d <- 128
result <- gmwm_simulation_study(theta_true = 2, d = d, n_simulations = 100)
#############################
gmwm_estimate <- function(d, initial_theta = 1, max_iter = 1000, tol = 1e-5) {
# Step 1: Generate a sample from the zero-mean process with covariance matrix Σ(θ)
set.seed(123)  # For reproducibility
I_d <- diag(d)  # Identity matrix of size d x d
theta_true <- 1  # True value of theta (for simulation purposes)
sample <- mvrnorm(n = 1, mu = rep(0, d), Sigma = theta_true * I_d)
# Step 2: Estimate wavelet variance on the sample using Haar wavelet
J <- floor(log2(d)) - 1  # Number of levels for Haar wavelet variance
estimated_wavelet_variance <- wvar(sample, filter = "haar", levels = J)$variance
# Step 3: Define the theoretical wavelet variance function as a function of θ
theoretical_wavelet_variance <- function(theta) {
# Theoretical wavelet variance implied by the process of interest
rep(theta, length(estimated_wavelet_variance))  # Assumes a simple linear relationship
}
# Step 4: Define the GMWM objective function to minimize
gmwm_objective <- function(theta) {
# Weighting matrix Ω (identity matrix for simplicity)
Omega <- diag(J)
# Compute the difference between estimated and theoretical wavelet variance
nu_hat <- estimated_wavelet_variance
nu_theta <- theoretical_wavelet_variance(theta)
diff <- nu_hat - nu_theta
# GMWM loss function: (ν̂ - ν(θ))' * Ω * (ν̂ - ν(θ))
t(diff) %*% Omega %*% diff
}
# Step 5: Optimize the objective function to estimate θ
result <- optim(par = initial_theta, fn = gmwm_objective, method = "BFGS",
control = list(maxit = max_iter, reltol = tol))
# Return the estimated value of θ
return(list(estimated_theta = result$par, convergence = result$convergence))
}
#######Problem2
#############################
# Required Libraries
library(MASS)          # For mvrnorm()
library(wv)            # For wvar() - Wavelet variance estimation
library(wavelets)      # For wt.filter() - To obtain wavelet filter
# Define the Generalized Method of Wavelet Moments (GMWM) simulation study
gmwm_simulation_study <- function(theta_true = 2, d = 128, n_simulations = 100) {
# Arguments:
# theta_true: True value of the parameter to estimate
# d: Dimension of the identity matrix (must be a power of 2)
# n_simulations: Number of simulations to perform
# Initialize storage for GMWM estimates
theta_estimates <- numeric(n_simulations)
# Define GMWM objective function
gmwm_objective <- function(theta, sample_variance, Omega) {
theoretical_variance <- numeric(J)
# Compute the theoretical wavelet variance for each level
for (j in 1:J) {
out <- wt.filter(filter = "haar", level = j)
filter <- out@h
I_j <- diag(2^j)               # Identity matrix of dimension 2^j x 2^j
Sigma_j_theta <- I_j * theta   # Compute Sigma_j(theta)
A_j <- filter %*% t(filter)    # Matrix A_j (related to Haar filter)
# Compute theoretical wavelet variance
theoretical_variance[j] <- sum(diag(A_j %*% Sigma_j_theta)) / (2^j)
}
# Compute the GMWM objective function
diff <- sample_variance - theoretical_variance
return(t(diff) %*% Omega %*% diff)
}
# Perform the simulation study
set.seed(123)
for (i in 1:n_simulations) {
# Simulate data using mvrnorm()
sample <- mvrnorm(n = 1, mu = rep(0, d), Sigma = diag(d) * theta_true)
# Estimate wavelet variance (robust or not)
J <- floor(log2(d)) - 1  # Number of levels for Haar wavelet variance
sample_variance <- suppressWarnings(wvar(sample, filter = "haar", n.levels = J)$variance)
# Weighting matrix (Identity matrix by default)
Omega <- diag(length(sample_variance))
# Optimize to get GMWM estimate for theta
result <- optim(par = 1, fn = gmwm_objective, sample_variance = sample_variance, Omega = Omega)
theta_estimates[i] <- result$par
}
# Set up plot margins to avoid figure margins error
dev.new(width = 8, height = 6)
par(mar = c(5, 4, 4, 2) + 0.1)
# Plotting the results using boxplot
boxplot(theta_estimates, main = "GMWM Estimates of Theta", ylab = "Theta Estimates")
# Calculate the Median Absolute Error (MAE)
MAE <- median(abs(theta_estimates - theta_true))
cat("Median Absolute Error (MAE):", MAE, "\n")
return(list(theta_estimates = theta_estimates, MAE = MAE))
}
# Run the simulation study
d <- 128
result <- gmwm_simulation_study(theta_true = 2, d = d, n_simulations = 100)
# Output the results
cat("Median Absolute Error (MAE):", result$MAE, "\n")
# Required Libraries
library(MASS)          # For mvrnorm()
library(wv)            # For wvar() - Wavelet variance estimation
library(wavelets)      # For wt.filter() - To obtain wavelet filter
# Define the Generalized Method of Wavelet Moments (GMWM) simulation study
gmwm_simulation_study <- function(theta_true = 2, d = 128, n_simulations = 100) {
# Arguments:
# theta_true: True value of the parameter to estimate
# d: Dimension of the identity matrix (must be a power of 2)
# n_simulations: Number of simulations to perform
# Initialize storage for GMWM estimates
theta_estimates <- numeric(n_simulations)
# Define GMWM objective function
gmwm_objective <- function(theta, sample_variance, Omega) {
theoretical_variance <- numeric(J)
# Compute the theoretical wavelet variance for each level
for (j in 1:J) {
out <- wt.filter(filter = "haar", level = j)
filter <- out@h
I_j <- diag(2^j)               # Identity matrix of dimension 2^j x 2^j
Sigma_j_theta <- I_j * theta   # Compute Sigma_j(theta)
A_j <- filter %*% t(filter)    # Matrix A_j (related to Haar filter)
# Compute theoretical wavelet variance
theoretical_variance[j] <- sum(diag(A_j %*% Sigma_j_theta)) / (2^j)
}
# Compute the GMWM objective function
diff <- sample_variance - theoretical_variance
return(t(diff) %*% Omega %*% diff)
}
# Perform the simulation study
set.seed(123)
for (i in 1:n_simulations) {
# Simulate data using mvrnorm()
sample <- mvrnorm(n = 1, mu = rep(0, d), Sigma = diag(d) * theta_true)
# Estimate wavelet variance (robust or not)
J <- floor(log2(d)) - 1  # Number of levels for Haar wavelet variance
sample_variance <- suppressWarnings(wvar(sample, filter = "haar", n.levels = J)$variance)
# Weighting matrix (Identity matrix by default)
Omega <- diag(length(sample_variance))
# Optimize to get GMWM estimate for theta
result <- optim(par = 1, fn = gmwm_objective, sample_variance = sample_variance, Omega = Omega)
theta_estimates[i] <- result$par
}
# Set up plot margins to avoid figure margins error
dev.new(width = 8, height = 6)
par(mar = c(5, 4, 4, 2) + 0.1)
# Plotting the results using boxplot
boxplot(theta_estimates, main = "GMWM Estimates of Theta", ylab = "Theta Estimates")
# Calculate the Median Absolute Error (MAE)
MAE <- median(abs(theta_estimates - theta_true))
cat("Median Absolute Error (MAE):", MAE, "\n")
# Calculate the 95% Confidence Interval for theta estimates
CI_lower <- quantile(theta_estimates, probs = 0.025)
CI_upper <- quantile(theta_estimates, probs = 0.975)
cat("95% Confidence Interval for Theta: [", CI_lower, ",", CI_upper, "]\n")
return(list(theta_estimates = theta_estimates, MAE = MAE, CI = c(CI_lower, CI_upper)))
}
# Run the simulation study
d <- 128
result <- gmwm_simulation_study(theta_true = 2, d = d, n_simulations = 100)
# Output the results
cat("Median Absolute Error (MAE):", result$MAE, "\n")
cat("95% Confidence Interval for Theta: [", result$CI[1], ",", result$CI[2], "]\n")
#Question1
library(MASS)       # For mvrnorm function
library(wv)         # For wvar function
library(wavelets)   # For wt.filter function
wv_theo <- function(theta, J) {
# Check that the parameters have been provided correctly
if (length(theta) != 1) {
stop("For an AR(1) process, theta should contain a single value: phi.")
}
# Extract the AR coefficient (phi) from the parameter vector
phi <- theta[1]
# Initialize an empty vector to store wavelet variances
wv <- numeric(J)
# Compute the wavelet variance for each scale j (1 to J)
for (j in 1:J) {
# Scale factor (2^j)
tau_j <- 2^j
# Compute the theoretical wavelet variance for AR(1) at scale j
wv[j] <- (1 - phi^2) / (1 + phi^2 - 2 * phi * cos(pi / tau_j))
}
return(wv)
}
# Example usage
theta <- c(0.5)  # AR(1) parameter phi
J <- 5           # Number of scales
wv <- wv_theo(theta, J)
print(wv)
#Question2
# Loss function for GMWM to estimate the parameter of the process
gmwm_loss <- function(theta, nu_hat) {
# Number of scales is the length of the empirical wavelet variance vector
J <- length(nu_hat)
# Compute the theoretical wavelet variance for the given parameter
wv_theo_values <- wv_theo(theta, J)
# Compute the loss using the identity matrix (i.e., no specific weighting)
# Loss = sum of squared differences between empirical (nu_hat) and theoretical wavelet variances
loss <- sum((nu_hat - wv_theo_values)^2)
return(loss)
}
# Example usage of the GMWM loss function
# Empirical wavelet variance (nu_hat) at different scales (J = 5)
nu_hat <- c(1.2, 0.9, 0.8, 0.5, 0.3)
theta <- c(0.5)  # Initial guess for parameter phi
# Calculate the loss for given theta
loss_value <- gmwm_loss(theta, nu_hat)
print(loss_value)
gmwm_loss
wv_theo_values
loss
return(loss)
nu_hat
theta
loss_value
library(MASS)       # For mvrnorm function
library(wv)         # For wvar function
library(wavelets)
wv_theo <- function(theta, J) {
# Assuming that J is a level and theta is a parameter
# You need to calculate the wavelet variance for each level J.
# Placeholder: Update this with the correct formula for wavelet variance.
wavelet_variance <- theta / (2 ^ J)
return(wavelet_variance)
}
eturn(wavelet_variance)
#Q2
gmwm_loss <- function(theta, nu_hat) {
# theta: the parameter to estimate
# nu_hat: the observed wavelet variance
# Calculate the theoretical wavelet variance
nu_theo <- wv_theo(theta, length(nu_hat))
# Identity matrix for Ω
Omega <- diag(length(nu_hat))
# Calculate the loss function as the quadratic form
loss <- t(nu_hat - nu_theo) %*% Omega %*% (nu_hat - nu_theo)
return(as.numeric(loss))
}
#Q3
gmwm <- function(x, robust = FALSE, start = var(x)) {
# x: the data
# robust: whether to use the robust estimator or not (default is FALSE)
# start: initial starting value for optimization (default is variance of x)
# Calculate the wavelet variance (using a placeholder for demonstration purposes)
if (robust) {
nu_hat <- wvar(x, robust = TRUE)$variance
} else {
nu_hat <- wvar(x, robust = FALSE)$variance
}
# Minimize the loss function to estimate theta
theta_hat <- suppressWarnings(optim(par = start, fn = gmwm_loss, nu_hat = nu_hat, method = "BFGS")$par)
# Return the estimated theta
return(theta_hat)
}
#Question3
gmwm <- function(x, robust = FALSE, start = var(x)) {
# x: the data
# robust: whether to use the robust estimator or not (default is FALSE)
# start: initial starting value for optimization (default is variance of x)
# Calculate the wavelet variance (using a placeholder for demonstration purposes)
if (robust) {
nu_hat <- wvar(x, robust = TRUE)$variance
} else {
nu_hat <- wvar(x, robust = FALSE)$variance
}
# Minimize the loss function to estimate theta
theta_hat <- suppressWarnings(optim(par = start, fn = gmwm_loss, nu_hat = nu_hat, method = "BFGS")$par)
# Return the estimated theta
return(theta_hat)
}
return(theta_hat)
return(theta_hat)
#Question1
library(MASS)       # For mvrnorm function
library(wv)         # For wvar function
library(wavelets)   # For wt.filter function
wv_theo <- function(theta, J) {
# Check that the parameters have been provided correctly
if (length(theta) != 1) {
stop("For an AR(1) process, theta should contain a single value: phi.")
}
# Extract the AR coefficient (phi) from the parameter vector
phi <- theta[1]
# Initialize an empty vector to store wavelet variances
wv <- numeric(J)
# Compute the wavelet variance for each scale j (1 to J)
for (j in 1:J) {
# Scale factor (2^j)
tau_j <- 2^j
# Compute the theoretical wavelet variance for AR(1) at scale j
wv[j] <- (1 - phi^2) / (1 + phi^2 - 2 * phi * cos(pi / tau_j))
}
return(wv)
}
# Example usage
theta <- c(0.5)  # AR(1) parameter phi
library(MASS)       # For mvrnorm function
library(wv)         # For wvar function
library(wavelets)
#Q1
wv_theo <- function(theta, J) {
# Assuming that J is a level and theta is a parameter
# You need to calculate the wavelet variance for each level J.
# Placeholder: Update this with the correct formula for wavelet variance.
wavelet_variance <- theta / (2 ^ J)
return(wavelet_variance)
}
#Q2
gmwm_loss <- function(theta, nu_hat) {
# theta: the parameter to estimate
# nu_hat: the observed wavelet variance
# Calculate the theoretical wavelet variance
nu_theo <- wv_theo(theta, length(nu_hat))
# Identity matrix for Ω
Omega <- diag(length(nu_hat))
# Calculate the loss function as the quadratic form
loss <- t(nu_hat - nu_theo) %*% Omega %*% (nu_hat - nu_theo)
return(as.numeric(loss))
}
#Q3
gmwm <- function(x, robust = FALSE, start = var(x)) {
# x: the data
# robust: whether to use the robust estimator or not (default is FALSE)
# start: initial starting value for optimization (default is variance of x)
# Calculate the wavelet variance (using a placeholder for demonstration purposes)
if (robust) {
nu_hat <- wvar(x, robust = TRUE)$variance
} else {
nu_hat <- wvar(x, robust = FALSE)$variance
}
# Minimize the loss function to estimate theta
theta_hat <- suppressWarnings(optim(par = start, fn = gmwm_loss, nu_hat = nu_hat, method = "BFGS")$par)
# Return the estimated theta
return(theta_hat)
}
# Run simulation study
set.seed(123) # Setting seed for reproducibility
#Q4
# Set parameters for the simulation
B <- 100        # Number of replications
d <- 1000       # Sample size
cont <- 10      # Number of contaminated observations
true_theta <- 2 # True value of theta
lambda <- 0.5   # Rate parameter for exponential contamination
# Initialize objects to store estimated parameters
theta_Xt_std <- numeric(B)
theta_Xt_rob <- numeric(B)
theta_Zt_std <- numeric(B)
theta_Zt_rob <- numeric(B)
# Run simulation study
set.seed(123) # Setting seed for reproducibility
for (b in 1:B) {
# Generate sample X from normal distribution with mean 0 and variance true_theta
X <- MASS::mvrnorm(n = d, mu = rep(0, 1), Sigma = true_theta)
# Create a copy Z and add contamination to it
Z <- X
Z[sample(1:d, cont)] <- rexp(cont, rate = lambda)
# Estimate theta for X using the standard and robust methods
theta_Xt_std[b] <- gmwm(X, robust = FALSE, start = true_theta)
theta_Xt_rob[b] <- gmwm(X, robust = TRUE, start = true_theta)
# Estimate theta for Z using the standard and robust methods
theta_Zt_std[b] <- gmwm(Z, robust = FALSE, start = true_theta)
theta_Zt_rob[b] <- gmwm(Z, robust = TRUE, start = true_theta)
}
# Store the estimated values in appropriate objects
results <- data.frame(
Theta_Xt_Standard = theta_Xt_std,
Theta_Xt_Robust = theta_Xt_rob,
Theta_Zt_Standard = theta_Zt_std,
Theta_Zt_Robust = theta_Zt_rob
)
# View the results
head(results)
