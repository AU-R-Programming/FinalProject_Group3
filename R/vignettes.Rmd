---
title: '"Vignette"'
output: html_document
date: "2024-12-03"
---


## FUNCTION -1 :COMPUTE METRICS

## Introduction

The `compute_metrics` function is designed to evaluate the performance of binary classification models. It calculates key metrics such as precision, recall, accuracy, and F1-score based on the actual binary labels (`y_true`) and predicted probabilities (`y_pred`). Additionally, it generates a confusion matrix and allows users to specify a custom decision threshold to classify probabilities into binary predictions (0 or 1). This function is essential for assessing the effectiveness of classification models and making data-driven decisions.


## Function Inputs:

```{r}
source(file = "C:/Users/aishw/Downloads/metrics.R")
```

```{r}
# Load the package containing the function
library(binaryClassifier)
```

## Purpose of the Function

The `compute_metrics` function calculates a confusion matrix and various classification metrics for evaluating binary classification models. It takes the actual binary values `(y_true)`, predicted probabilities `(y_pred)`, and an optional classification threshold as inputs and returns a list containing the confusion matrix and performance metrics.

## Step-by-Step Explanation

`y_true`: A vector of actual binary labels (0 or 1).

`y_pred`: A vector of predicted probabilities (typically the output from a logistic regression model).

threshold: A value to convert predicted probabilities into binary predictions (default is 0.5). This allows users to set a custom decision boundary to classify probabilities as 0 or 1.

## Convert Probabilities to Binary Classification:

The following line of code converts predicted probabilities `(y_pred)` into binary values based on the threshold:

```{r}

compute_metrics <- function(y_true, y_pred, threshold = 0.5) 
  # Convert predicted probabilities to binary classification using the threshold
y_pred_class <- ifelse(y_pred > threshold, 1, 0)
```


## Example Usage

### Reading the data

```{r}
# Read the CSV file
data <- read.csv("C:/Users/aishw/Downloads/rainfall.csv")

# View the structure of the data
str(data)
```

### preparing data
```{r}

# View the first few rows to understand the structure
head(data)

# Here, we'll assume `y_true` and `y_pred` columns exist or will be created from the `PRECIP..mm.` values

# For demonstration, let's create a binary outcome `y_true` (0 or 1) based on whether precipitation exceeds a threshold (e.g., 10 mm)
y_true <- ifelse(data$PRECIP..mm. > 10, 1, 0)

# Let's simulate some predicted probabilities (e.g., using a simple model or random numbers)
set.seed(42)  # For reproducibility
y_pred <- runif(length(y_true), min = 0, max = 1)  # Random predicted probabilities between 0 and 1

# Extract predictors (in this case, we'll just use the precipitation value as the predictor)
X <- as.matrix(data$PRECIP..mm.)

# Ensure the data is ready for use
head(y_true)
head(y_pred)


```
### example

We will now use the compute_metrics function to calculate classification metrics based on the y_true and y_pred values.

```{r}
# Compute confusion matrix and metrics
metrics_result <- compute_metrics(y_true, y_pred)

# View the results
metrics_result
```
This will output the confusion matrix along with other performance metrics such as accuracy, precision, recall, F1-score, etc.



## FUNCTION -2 : BOOTSTRAP CONFIDENCE INTERVALS FOR LOGISTIC REGRESSION

## Introduction

This vignette demonstrates the use of the `bootstrap_ci` function, which computes confidence intervals for logistic regression coefficients using bootstrap resampling.


## Function Inputs:

```{r}
# Set the working directory to where the function script is saved
setwd("C:/Users/aishw/OneDrive - Auburn University/Documents/GitHub/FinalProject_Group3/R")

# Source the logistic regression and bootstrap CI functions
source("logistic_regression.R")
source("C:/Users/aishw/Downloads/bootstrap_ci.R")
```

## Purpose of the Function

The **`bootstrap_ci`** function is designed to:
1. Estimate logistic regression coefficients through bootstrap resampling.
2. Calculate confidence intervals for the coefficients using the specified significance level.

## Step-by-Step Explanation

`X`: A numeric matrix of predictor variables.

`y`: A binary numeric vector of responses (0/1).

`n_boot`: Number of bootstrap iterations (default is 20).

`alpha`: Significance level for confidence intervals (default is 0.05).

The function outputs a data frame containing:
-Estimated coefficients.
-Lower and upper bounds of the confidence intervals.

```{r}
bootstrap_ci <- function(X, y, n_boot = 20, alpha = 0.05) {
  beta_estimates <- replicate(n_boot, {
    idx <- sample(1:nrow(X), replace = TRUE)
    logistic_regression(X[idx, ], y[idx])$coefficients
  })
  
  ci <- apply(beta_estimates, 1, quantile, probs = c(alpha / 2, 1 - alpha / 2))
  
  confidence_intervals <- data.frame(
    Coefficient = rownames(ci),
    Lower = ci[1, ],
    Upper = ci[2, ]
  )
  
  return(confidence_intervals)
}
```
 
## Example Usage

Now, we will use the `bootstrap_ci` function to calculate confidence intervals for the logistic regression coefficients based on the predictor matrix `X` (precipitation in mm) and the actual binary labels `y_true`.

```{r}
# Load necessary libraries
library(MASS)

# Read the rainfall data
data <- read.csv("C:/Users/aishw/Downloads/rainfall.csv")

# View the structure of the data
str(data)

# Prepare the predictor (PRECIP..mm.) and binary response (y)
X <- as.matrix(data[, c("PRECIP..mm.")])  # Assuming PRECIP..mm. is the predictor
y <- ifelse(data$PRECIP..mm. > 10, 1, 0)  # Creating binary labels based on a threshold (10 mm)

# Check for missing or infinite values
sum(is.na(X))  # Should be 0
sum(is.infinite(X))  # Should be 0
sum(is.na(y))  # Should be 0
sum(is.infinite(y))  # Should be 0

log_likelihood <- function(beta, X, y) {
  p <- 1 / (1 + exp(-X %*% beta))  # Logistic regression model
  sum(y * log(p) + (1 - y) * log(1 - p))  # Log-likelihood function
}

# Check the dimensions of X and length of y
dim(X)  # Should return a matrix with dimensions (n, p)
length(y)  # Should return n (same as number of rows in X)

# Make sure X is a matrix and y is a vector
X <- as.matrix(X)
y <- as.vector(y)

# Check that the number of rows in X matches the length of y
nrow(X) == length(y)  # Should return TRUE


# Check for missing values in X and y
sum(is.na(X))  # Should return 0 (no NAs)
sum(is.na(y))  # Should return 0 (no NAs)

# Ensure X is a matrix and y is a vector
X <- as.matrix(X)  # Convert X to a matrix
y <- as.vector(y)  # Convert y to a vector

# Check dimensions of X and y
if (nrow(X) != length(y)) {
  stop("The number of rows in X does not match the length of y")
}

# Remove rows with missing values in X or y
valid_rows <- complete.cases(X, y)

# Subset the data based on valid rows
X <- X[valid_rows, , drop = FALSE]
y <- y[valid_rows]

# Check if X and y have the same number of rows now
nrow(X) == length(y)  # Should return TRUE

# Define your bootstrap function
bootstrap_ci <- function(X, y, n_boot = 1000, alpha = 0.05) {
  # Initialize a vector to store the bootstrap estimates
  boot_estimates <- numeric(n_boot)
  
  # Perform bootstrap sampling
  for (i in 1:n_boot) {
    # Sample with replacement
    sample_indices <- sample(1:nrow(X), replace = TRUE)
    X_boot <- X[sample_indices, , drop = FALSE]
    y_boot <- y[sample_indices]
    
    # Fit the model on the bootstrap sample (adjust based on your specific model)
    # For example, let's say you're fitting a simple linear regression
    model <- lm(y_boot ~ X_boot - 1)  # No intercept
    
    # Save the coefficient of interest (e.g., the first coefficient)
    boot_estimates[i] <- coef(model)[1]
  }
  
  # Calculate the bootstrap confidence interval
  lower_ci <- quantile(boot_estimates, alpha / 2)
  upper_ci <- quantile(boot_estimates, 1 - alpha / 2)
  
  # Return the results
  return(list(estimate = mean(boot_estimates), lower_ci = lower_ci, upper_ci = upper_ci))
}

# Now apply the bootstrap function to your cleaned data (X, y)
bootstrap_result <- bootstrap_ci(X, y, n_boot = 1000, alpha = 0.05)

# Print the results
print(paste("Bootstrap Estimate:", round(bootstrap_result$estimate, 3)))
print(paste("95% Confidence Interval: [", round(bootstrap_result$lower_ci, 3), ", ", round(bootstrap_result$upper_ci, 3), "]"))
```


```{r}
devtools::install_github("AU-R-Programming/FinalProject_Group3")

```



## Introduction

This vignette demonstrates the usage of the `logistic_regression()` function, which estimates the coefficients of a logistic regression model using numerical optimization. The function maximizes the log-likelihood to estimate the model parameters.

##function inputs
```{r}
source(file = "C:/Users/aishw/Downloads/logistic_regression (1).R")

```

## Function purpose

The `logistic_regression()` function takes a matrix of predictors (`X`) and a vector of binary responses (`y`). It adds an intercept column to the predictors and uses numerical optimization to maximize the log-likelihood, returning the estimated coefficients.

## Function Usage

To use the function, simply pass the predictors and responses into the function:

```{r setup, echo=TRUE}

 install.packages("stats")  
```

```{r}
logistic_regression <- function(X, y) {
  X <- cbind(1, X)  # Add intercept column
  n <- nrow(X)
  p <- ncol(X)
  
  XtX <- t(X) %*% X
  XtY <- t(X) %*% y
  
  beta_init <- solve(XtX, XtY)
  
  log_likelihood <- function(beta) {
    linear_pred <- X %*% beta
    p <- 1 / (1 + exp(-linear_pred))
    -sum(y * log(p) + (1 - y) * log(1 - p))
  }
  
  opt <- optim(par = beta_init, fn = log_likelihood, method = "BFGS")
  beta <- opt$par
  
  list(coefficients = beta)
}
```
## example Usage
### Load the Rainfall Data

We will use a CSV file containing rainfall data. The dataset includes various predictors and a binary response variable indicating whether a certain threshold of rainfall was exceeded (e.g., drought/no-drought).

```{r}
# Load necessary libraries
library(stats)

# Load the rainfall dataset (ensure the file path is correct)
rainfall_data <-read.csv("C:/Users/aishw/Downloads/rainfall.csv")


# Inspect the first few rows of the data
head(rainfall_data)
```

### data preparation
```{r}
# Check the column names of the dataframe
colnames(rainfall_data)

# Rename columns for easier reference
colnames(rainfall_data) <- c("datetime_seconds", "precip_mm")

# If 'rainy' is a binary variable based on precip_mm, e.g., 1 for rain, 0 for no rain
rainfall_data$rainy <- ifelse(rainfall_data$precip_mm > 0, 1, 0)

# Now, define the predictors and response
X <- rainfall_data[, c("precip_mm")]  # Example: using precip_mm as the predictor
y <- rainfall_data$rainy  # Binary response (0 = no rain, 1 = rain)

# Check the structure of the data
dim(X)  # Should return (n, p)
length(y)  # Should return n, same as the number of rows in X
```
```{r}
# Verify dimensions and structure
head(rainfall_data)
dim(X)  # Number of rows (n) and columns (p) in X
length(y)  # Length of y (same as number of rows in X)
```


